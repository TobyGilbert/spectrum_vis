#include "base.h"

bool g_app_run(false);
LARGE_INTEGER g_pc_freq;

int g_window_width = 768;
int g_window_height = 480;

HINSTANCE g_app_instance; // The HINSTANCE of this application  
LRESULT CALLBACK winproc_callback(HWND, UINT, WPARAM, LPARAM); // Standard window callback

HDC hdc; // Device context   
HGLRC hrc; // Rendering context  
HWND hwnd;

HWND create_window(LPCSTR title) 
{    
	WNDCLASS window_class;  
	HWND hwnd;
	DWORD extended_window_style = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;  
	  
	g_app_instance = GetModuleHandle(NULL);  
	  
	window_class.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;  
	window_class.lpfnWndProc = (WNDPROC) winproc_callback;  
	window_class.cbClsExtra = 0;  
	window_class.cbWndExtra = 0;  
	window_class.hInstance = g_app_instance;  
	window_class.hIcon = LoadIcon(NULL, IDI_WINLOGO);  
	window_class.hCursor = LoadCursor(NULL, IDC_ARROW);  
	window_class.hbrBackground = NULL;  
	window_class.lpszMenuName = NULL;  
	window_class.lpszClassName = title;  
	  
	if (!RegisterClass(&window_class)) 
	{  
		return NULL;  
	}  

	hwnd = CreateWindowEx(	extended_window_style, 
							title, 
							title, 
							WS_OVERLAPPEDWINDOW,  
							CW_USEDEFAULT, 
							0, 
							g_window_width, 
							g_window_height, 
							NULL, 
							NULL, 
							g_app_instance, 
							NULL);   
	  
	ShowWindow(hwnd, SW_SHOW); 

	UpdateWindow(hwnd);  
	  
	return hwnd;  

}

HGLRC setup_rc(HWND hwnd, HDC hdc)
{
	PIXELFORMATDESCRIPTOR pfd =
	{
		sizeof(PIXELFORMATDESCRIPTOR),
		1,
		PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,    //Flags
		PFD_TYPE_RGBA,            //The kind of framebuffer. RGBA or palette.
		32,                        //Colordepth of the framebuffer.
		0, 0, 0, 0, 0, 0,
		0,
		0,
		0,
		0, 0, 0, 0,
		24,                        //Number of bits for the depthbuffer
		8,                        //Number of bits for the stencilbuffer
		0,                        //Number of Aux buffers in the framebuffer.
		PFD_MAIN_PLANE,				// Set the layer of the PFD
		0,
		0, 0, 0
	};

	// Check if our PFD is valid and get a pixel format back
	int dc_pixel_format = ChoosePixelFormat(hdc, &pfd);  

	if (dc_pixel_format == 0)   
		return NULL;  
	  
	// Try and set the pixel format based on our PFD
	if (!SetPixelFormat(hdc, dc_pixel_format, &pfd)) // If it fails  
		return NULL;  

	// Create an OpenGL 2.1 context for our device context
	HGLRC tmp_glctxt = wglCreateContext(hdc); 

	// Make the OpenGL 2.1 context current and active  
	wglMakeCurrent(hdc, tmp_glctxt);  

	int attributes[] = {  
		WGL_CONTEXT_MAJOR_VERSION_ARB, 3, 
		WGL_CONTEXT_MINOR_VERSION_ARB, 2, 
		WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,   
		0  
	}; 

	// If the OpenGL 3.x context creation extension is available 
	if (glewIsSupported("WGL_ARB_create_context") == 1) 
	{  
		// Create and OpenGL 3.x context based on the given attributes
		hrc = wglCreateContextAttribsARB(hdc, NULL, attributes);
		// Remove the temporary context from being active
		wglMakeCurrent(NULL, NULL);   
		// Delete the temporary OpenGL 2.1 context
		wglDeleteContext(tmp_glctxt);
		// Make our OpenGL 3.0 context current    
		wglMakeCurrent(hdc, hrc);  
	}  
	else 
	{  
		// If we didn't have support for OpenGL 3.x and up...
		return NULL;
	}

	return hrc;
}

LRESULT CALLBACK winproc_callback( 	HWND hWnd, 
									UINT message, 
									WPARAM wParam, 
									LPARAM lParam) 
{  
	switch (message) 
	{    
		case WM_DESTROY: 
		PostQuitMessage(0); 
		break; 
	}  
  
	return DefWindowProc(hWnd, message, wParam, lParam);  
}  

bool init(void)
{
	if(!QueryPerformanceFrequency(&g_pc_freq))
		return false;
	else
		printf("system perf counter frequency: %lld\n", g_pc_freq.QuadPart);  
	
	// Create our OpenGL window 
	hwnd = create_window("SPECTRUM-VIZ");

	// Get the device context for our window 
	hdc = GetDC(hwnd); 

	// Create our OpenGL context on the given window we just created
	hrc = setup_rc(hwnd, hdc);

	// initialise glew
	if (glewInit() != GLEW_OK)
		return false;
	else
		// clear errors generated by glew
	  	glGetError();

	// Initialize bass 
	int default_device = -1; // Default Sounddevice
	int sampling_frequency = 44100; // Sample rate (Hz)
	BASS_Init(default_device, sampling_frequency, 0, 0, NULL);

	// Set the viewport size to fill the window
	glViewport(0, 0, g_window_width, g_window_height);   
	glClearColor(0.0, 0.0, 0.0, 1.0);

	if (!fspec_init())
		return false;

	return true;
}

void teardown(void)
{
	fspec_teardown();

	BASS_Free();

	// Remove the rendering context from our device context 
	wglMakeCurrent(hdc, NULL);  

	// Delete our rendering context  
	wglDeleteContext(hrc); 
	  
	// Release the device context from our window 
	ReleaseDC(hwnd, hdc); 
}

void execute(void)
{
	g_app_run = init();

	if(!g_app_run)
		return;

	float delta(0.0f);
	LARGE_INTEGER prev, crnt;

	QueryPerformanceCounter(&prev);

	MSG msg;

	while(g_app_run)
	{
		QueryPerformanceCounter(&crnt);

		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
		{ // If we have a message to process, process it  
			if (msg.message == WM_QUIT)		
			{  
				g_app_run = false; // Set g_app_run to false if we have a message to quit  
			}  
			else 
			{  
				TranslateMessage(&msg);  
				DispatchMessage(&msg);  
			}  
		}  
		 
		delta = float((double(crnt.QuadPart - prev.QuadPart) / g_pc_freq.QuadPart) / 1000.0);

		fspec_update(delta);

		glClear(GL_COLOR_BUFFER_BIT);
		fspec_render();
		SwapBuffers(hdc); // Swap buffers so we can see our rendering 
		

		prev.QuadPart = crnt.QuadPart;
	}

	teardown();
}

int WINAPI WinMain( HINSTANCE hInstance, 
					HINSTANCE hPrevInstance,  
					LPSTR lpCmdLine, 
					int nCmdShow) 
{   
	execute();
	  
	return 0;  
} 